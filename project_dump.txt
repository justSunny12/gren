
================================================================================
### .gitignore
================================================================================

#MacOS specific
.DS_Store
**/.DS_Store

# Byte-compiled / optimized / DLL files
__pycache__/
*.py[codz]
*$py.class

# C extensions
*.so

# saved dialogs cache
saved_dialogs/

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
venv/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py.cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock
#poetry.toml

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#   pdm recommends including project-wide configuration in pdm.toml, but excluding .pdm-python.
#   https://pdm-project.org/en/latest/usage/project/#working-with-version-control
#pdm.lock
#pdm.toml
.pdm-python
.pdm-build/

# pixi
#   Similar to Pipfile.lock, it is generally recommended to include pixi.lock in version control.
#pixi.lock
#   Pixi creates a virtual environment in the .pixi directory, just like venv module creates one
#   in the .venv directory. It is recommended not to include this directory in version control.
.pixi

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.envrc
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# Abstra
# Abstra is an AI-powered process automation framework.
# Ignore directories containing user credentials, local state, and settings.
# Learn more at https://abstra.io/docs
.abstra/

# Visual Studio Code
#  Visual Studio Code specific template is maintained in a separate VisualStudioCode.gitignore 
#  that can be found at https://github.com/github/gitignore/blob/main/Global/VisualStudioCode.gitignore
#  and can be added to the global gitignore or merged into this file. However, if you prefer, 
#  you could uncomment the following to ignore the entire vscode folder
# .vscode/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc

# Cursor
#  Cursor is an AI-powered code editor. `.cursorignore` specifies files/directories to
#  exclude from AI features like autocomplete and code analysis. Recommended for sensitive data
#  refer to https://docs.cursor.com/context/ignore-files
.cursorignore
.cursorindexingignore

# Marimo
marimo/_static/
marimo/_lsp/
__marimo__/

================================================================================
### classes/dialog_manager.py
================================================================================

# /classes/dialog_manager.py
import json
import os
from datetime import datetime

class DialogManager:
    """Менеджер для управления диалогами/чатами"""
    
    def __init__(self):
        self.dialogs = {}  # {dialog_id: {"name": str, "history": list, "created": timestamp}}
        self.current_dialog_id = None
        self.next_dialog_id = 1
        
        # Создаем директорию для сохранения диалогов
        self.save_dir = "saved_dialogs"
        os.makedirs(self.save_dir, exist_ok=True)
        self.load_dialogs()
    
    def create_new_dialog(self, name=None):
        """Создает новый диалог"""
        dialog_id = str(self.next_dialog_id)
        self.next_dialog_id += 1
        
        if not name:
            name = f"Чат {dialog_id}"
        
        self.dialogs[dialog_id] = {
            "id": dialog_id,
            "name": name,
            "history": [],
            "created": datetime.now().isoformat(),
            "updated": datetime.now().isoformat()
        }
        
        self.current_dialog_id = dialog_id
        self.save_dialogs()
        return dialog_id
    
    def switch_dialog(self, dialog_id):
        """Переключается на указанный диалог"""
        if dialog_id in self.dialogs:
            self.current_dialog_id = dialog_id
            return True
        return False
    
    def delete_dialog(self, dialog_id):
        """Удаляет диалог"""
        if dialog_id in self.dialogs:
            # Удаляем файл с диалогом
            dialog_file = os.path.join(self.save_dir, f"dialog_{dialog_id}.json")
            if os.path.exists(dialog_file):
                os.remove(dialog_file)
            
            del self.dialogs[dialog_id]
            
            # Если удалили текущий диалог, переключаемся на другой
            if self.current_dialog_id == dialog_id:
                if self.dialogs:
                    self.current_dialog_id = list(self.dialogs.keys())[0]
                else:
                    self.current_dialog_id = None
            
            self.save_dialogs()
            return True
        return False
    
    def rename_dialog(self, dialog_id, new_name):
        """Переименовывает диалог"""
        if dialog_id in self.dialogs:
            self.dialogs[dialog_id]["name"] = new_name
            self.dialogs[dialog_id]["updated"] = datetime.now().isoformat()
            self.save_dialogs()
            return True
        return False
    
    def get_current_dialog(self):
        """Получает текущий активный диалог"""
        if self.current_dialog_id and self.current_dialog_id in self.dialogs:
            return self.dialogs[self.current_dialog_id]
        return None
    
    def get_dialog_list(self):
        """Получает список всех диалогов"""
        dialogs_list = []
        for dialog_id, dialog_info in self.dialogs.items():
            dialogs_list.append({
                "id": dialog_id,
                "name": dialog_info["name"],
                "history_length": len(dialog_info["history"]),
                "created": dialog_info["created"],
                "updated": dialog_info["updated"],
                "is_current": (dialog_id == self.current_dialog_id)
            })
        
        # Сортируем по дате обновления (свежие сверху)
        dialogs_list.sort(key=lambda x: x["updated"], reverse=True)
        return dialogs_list
    
    def add_message(self, dialog_id, role, content):
        """Добавляет сообщение в диалог"""
        if dialog_id in self.dialogs:
            self.dialogs[dialog_id]["history"].append({
                "role": role,
                "content": content,
                "timestamp": datetime.now().isoformat()
            })
            self.dialogs[dialog_id]["updated"] = datetime.now().isoformat()
            self.save_dialogs()
    
    def clear_dialog(self, dialog_id):
        """Очищает историю диалога"""
        if dialog_id in self.dialogs:
            self.dialogs[dialog_id]["history"] = []
            self.dialogs[dialog_id]["updated"] = datetime.now().isoformat()
            self.save_dialogs()
    
    def save_dialogs(self):
        """Сохраняет все диалоги в файлы"""
        for dialog_id, dialog_info in self.dialogs.items():
            dialog_file = os.path.join(self.save_dir, f"dialog_{dialog_id}.json")
            with open(dialog_file, 'w', encoding='utf-8') as f:
                json.dump(dialog_info, f, ensure_ascii=False, indent=2)
    
    def load_dialogs(self):
        """Загружает сохраненные диалоги"""
        try:
            dialog_files = [f for f in os.listdir(self.save_dir) if f.startswith("dialog_") and f.endswith(".json")]
            
            for dialog_file in dialog_files:
                file_path = os.path.join(self.save_dir, dialog_file)
                with open(file_path, 'r', encoding='utf-8') as f:
                    dialog_info = json.load(f)
                
                dialog_id = dialog_info["id"]
                self.dialogs[dialog_id] = dialog_info
                
                # Обновляем next_dialog_id
                dialog_num = int(dialog_id)
                if dialog_num >= self.next_dialog_id:
                    self.next_dialog_id = dialog_num + 1
            
            # Устанавливаем текущий диалог как последний обновленный
            if self.dialogs:
                dialogs_list = self.get_dialog_list()
                self.current_dialog_id = dialogs_list[0]["id"]
                
        except Exception as e:
            print(f"Ошибка при загрузке диалогов: {e}")
================================================================================
### config/app_config.yaml
================================================================================

# Основные настройки приложения
app:
  name: "Qwen3-4B Chat"
  version: "1.0.0"
  debug: false
  theme: "soft"

server:
  host: "0.0.0.0"
  port: 7860
  share: false
  show_error: true

queue:
  max_size: 5
  concurrency_limit: 1

dialogs:
  save_dir: "saved_dialogs"
  default_name: "Новый чат"
================================================================================
### config/model_config.yaml
================================================================================

# Настройки модели и генерации
model:
  name: "Qwen/Qwen3-4B"
  dtype: "bfloat16"  # auto, float16, bfloat16
  attn_implementation: "eager"
  low_cpu_mem_usage: true

generation:
  default_max_tokens: 512
  default_temperature: 0.7
  default_top_p: 0.9
  default_repetition_penalty: 1.1
  
  min_max_tokens: 64
  max_max_tokens: 2048
  min_temperature: 0.1
  max_temperature: 1.5

chat_naming:
  max_name_length: 50
  summary_max_tokens: 20
  summary_temperature: 0.4
================================================================================
### config/paths_config.yaml
================================================================================

# Пути к файлам и директориям
paths:
  css_dir: "css"
  saved_dialogs: "saved_dialogs"
  logs: "logs"
  
  css_files:
    - "css/base.css"
    - "css/sidebar.css"
    - "css/chat_window.css"
    - "css/input_area.css"
================================================================================
### config/ui_config.yaml
================================================================================

# Настройки интерфейса
sidebar:
  width: "300px"
  min_width: "300px"
  max_width: "350px"
  background: "#f8f9fa"
  border_color: "#e0e0e0"

chat_window:
  background: "white"
  border_color: "#e0e0e0"
  border_radius: "8px"
  padding: "12px"

input_area:
  height: "110px"
  min_height: "110px"
  max_height: "110px"
  background: "white"
  border_color: "#e0e0e0"
  border_radius: "6px"

buttons:
  primary_color: "#007bff"
  primary_hover: "#0056b3"
  secondary_color: "#6c757d"
  danger_color: "#dc3545"

text:
  font_family: "inherit"
  font_size: "14px"
  line_height: "1.4"

messages:
  user_bg: "#e3f2fd"
  user_border: "#bbdefb"
  bot_bg: "#f5f5f5"
  bot_border: "#e0e0e0"
  max_width: "75%"
  border_radius: "12px"
  padding: "10px 14px"
================================================================================
### container.py
================================================================================

# /container.py (убираем отладочные сообщения)
from typing import Dict, Any

class Container:
    """Упрощенный контейнер зависимостей"""
    
    def __init__(self):
        self._services: Dict[str, Any] = {}
        self._initializing = False
    
    def get(self, name: str) -> Any:
        """Получает сервис по имени (без логирования)"""
        if name not in self._services:
            # Ленивая загрузка сервисов
            if name == "config_service":
                from services.config_service import ConfigService
                self._services["config_service"] = ConfigService()
            elif name == "model_service":
                from services.model_service import ModelService
                self._services["model_service"] = ModelService()
            elif name == "dialog_service":
                from services.dialog_service import dialog_service
                self._services["dialog_service"] = dialog_service
            elif name == "chat_service":
                from services.chat_service import ChatService
                self._services["chat_service"] = ChatService()
            else:
                raise ValueError(f"Сервис не найден: {name}")
        
        return self._services[name]
    
    def get_config(self):
        return self.get("config_service").get_config()
    
    def get_chat_service(self):
        return self.get("chat_service")
    
    def get_dialog_service(self):
        return self.get("dialog_service")
    
    def get_model_service(self):
        return self.get("model_service")

# Глобальный контейнер
container = Container()
================================================================================
### css/base.css
================================================================================

/* css/base.css - Базовые сбросы и общие стили */
* {
    box-sizing: border-box !important;
}

body, html, .gradio-container {
    margin: 0 !important;
    padding: 0 !important;
    height: 100vh !important;
    width: 100vw !important;
    overflow: hidden !important;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;
}

/* Основной контейнер - жесткий контроль */
.gradio-container, 
.gradio-container > div,
.gradio-container > div > div {
    height: 100vh !important;
    max-height: 100vh !important;
    min-height: 100vh !important;
    background: white !important;
}

/* Жесткий сброс Gradio стилей */
.gr-box, .gr-form, .gr-panel, .gr-group {
    border: none !important;
    margin: 0 !important;
    padding: 0 !important;
    background: transparent !important;
}

/* Основной ряд - занимает всю высоту */
.main-row {
    height: 100vh !important;
    max-height: 100vh !important;
    min-height: 100vh !important;
    margin: 0 !important;
    padding: 0 !important;
    flex-wrap: nowrap !important;
    display: flex !important;
    background: white !important;
}

/* Основной контент - занимает оставшееся */
.main-content {
    height: 100vh !important;
    max-height: 100vh !important;
    min-height: 100vh !important;
    padding: 0 !important;
    margin: 0 !important;
    flex: 1 !important;
    min-width: 0 !important;
    display: flex !important;
    flex-direction: column !important;
    background: white !important;
}

/* Главный контейнер чата */
.chat-main-container {
    height: calc(100vh - 20px) !important;
    max-height: calc(100vh - 20px) !important;
    min-height: calc(100vh - 20px) !important;
    padding: 0 !important;          /* ← УБЕДИТЕСЬ, ЧТО padding: 0 */
    margin: 0 !important;           /* ← УБЕДИТЕСЬ, ЧТО margin: 0 */
    display: flex !important;
    flex-direction: column !important;
    flex: 1 !important;
    min-height: 0 !important;
    gap: 8 !important;              /* ← Убираем gap если есть */
    background: white !important;
    border: none !important;
    box-shadow: none !important;
}

.chat-main-container > * {
    margin: 0 !important;
    padding: 0 !important;
}

/* Фикс для flex элементов */
.wrap, .wrap.column {
    height: auto !important;
    min-height: 0 !important;
    margin: 0 !important;
    padding: 0 !important;
    background: transparent !important;
}

/* Убираем лишние отступы у Gradio элементов */
.gr-column, .gr-row {
    margin: 0 !important;
    padding: 0 !important;
    background: transparent !important;
}

/* Убираем outline у всех элементов при фокусе */
*:focus {
    outline: none !important;
}

/* Сброс всех кнопок Gradio */
button.gr-button {
    border-radius: 6px !important;
    border: none !important;
    transition: all 0.2s ease !important;
}

/* Сброс всех инпутов */
input, textarea, select {
    border-radius: 6px !important;
    border: 1px solid #d0d0d0 !important;
}
================================================================================
### css/chat_window.css
================================================================================

/* chat_window.css - ЕДИНЫЕ СТИЛИ ДЛЯ ВСЕХ ПУЗЫРЕЙ */
.chat-window-container {
    flex: 1 !important;
    min-height: 0 !important;
    overflow-y: auto !important;
    border: 1px solid #e0e0e0 !important;
    border-radius: 8px !important;
    background: white !important;
    box-sizing: border-box !important;
    padding: 12px !important;
}

/* Чатбот */
.chat-window-container .chatbot {
    display: flex !important;
    flex-direction: column !important;
    gap: 12px !important;
    margin: 0 !important;
    padding: 0 !important;
    border: none !important;
    background: transparent !important;
}

/* Контейнеры сообщений */
.chat-window-container .chatbot > div {
    margin: 0 !important;
    padding: 0 !important;
    border: none !important;
    display: flex !important;
    width: 100% !important;
    min-height: auto !important;
    height: auto !important;
}

/* СООБЩЕНИЯ ПОЛЬЗОВАТЕЛЯ - отличные стили, оставляем как есть */
.chat-window-container .message.user {
    background-color: #e3f2fd !important;
    border: 1px solid #bbdefb !important;
    border-radius: 12px 12px 0 12px !important;
    padding: 10px 14px !important;
    margin-left: auto !important;
    margin-right: 0 !important;
    max-width: 75% !important;
    min-width: fit-content !important;
    word-wrap: break-word !important;
    white-space: pre-wrap !important;
    line-height: 1.4 !important;
    margin-bottom: 0 !important;
    padding-bottom: 10px !important;
    display: inline-block !important;
    position: relative !important;
}

/* СООБЩЕНИЯ АССИСТЕНТА - КОПИРУЕМ СТИЛИ С ПОЛЬЗОВАТЕЛЬСКИХ, но с другими углами */
.chat-window-container .message.bot {
    background-color: #f5f5f5 !important;
    border: 1px solid #e0e0e0 !important;
    border-radius: 12px 12px 12px 0 !important; /* Только углы разные! */
    padding: 10px 14px !important;               /* Такой же padding */
    margin-left: 0 !important;
    margin-right: auto !important;
    max-width: 75% !important;                   /* Такой же max-width */
    min-width: fit-content !important;           /* Такой же min-width */
    word-wrap: break-word !important;            /* Такой же перенос */
    white-space: pre-wrap !important;            /* Такой же white-space */
    line-height: 1.4 !important;                 /* Такой же line-height */
    margin-bottom: 0 !important;                 /* Такой же margin-bottom */
    padding-bottom: 10px !important;             /* Такой же padding-bottom */
    display: inline-block !important;            /* Такой же display */
    position: relative !important;               /* Такой же position */
}

/* КОНТЕЙНЕРЫ для разных типов */
.chat-window-container .chatbot > div[data-testid="user"] {
    justify-content: flex-end !important;
    align-items: flex-start !important;
}

.chat-window-container .chatbot > div[data-testid="bot"] {
    justify-content: flex-start !important;
    align-items: flex-start !important;
}

/* ВНУТРЕННИЕ ЭЛЕМЕНТЫ сообщений - одинаковые для всех */
.chat-window-container .message {
    display: inline-block !important;
    position: relative !important;
}

/* Текст в сообщениях - одинаковые для всех */
.chat-window-container .message p {
    margin: 0 0 4px 0 !important;
    line-height: 1.4 !important;
    word-break: break-word !important;
}

.chat-window-container .message p:last-child {
    margin-bottom: 0 !important;
}

/* Убираем пустые элементы */
.chat-window-container .message p:empty:not(:has(*)) {
    display: none !important;
}

/* Аватары */
.chat-window-container .avatar {
    width: 32px !important;
    height: 32px !important;
    min-width: 32px !important;
    min-height: 32px !important;
    margin: 0 8px !important;
    align-self: flex-start !important;
}

/* Стили для скроллбара чата */
.chat-window-container::-webkit-scrollbar {
    width: 8px !important;
}

.chat-window-container::-webkit-scrollbar-track {
    background: #f8f9fa !important;
    border-radius: 4px !important;
}

.chat-window-container::-webkit-scrollbar-thumb {
    background: #ced4da !important;
    border-radius: 4px !important;
}

.chat-window-container::-webkit-scrollbar-thumb:hover {
    background: #adb5bd !important;
}

/* ФИКС для Gradio контейнеров */
.chatbot .wrap.s {
    margin: 0 !important;
    padding: 0 !important;
}

.chat-window-container .chatbot > div .wrap,
.chat-window-container .chatbot > div .wrap.s,
.chat-window-container .chatbot > div .wrap.s.column {
    margin: 0 !important;
    padding: 0 !important;
    gap: 0 !important;
    border: none !important;
}

/* Просто скрываем ВСЕ кнопки с классом icon-button */
.chatbot .icon-button,
.chatbot button.icon-button {
    display: none !important;
}

================================================================================
### css/input_area.css
================================================================================

/* input_area.css - Нормальные стили */
.input-plate {
    flex-shrink: 0 !important;
    height: 110px !important;
    min-height: 110px !important;
    max-height: 110px !important;
    box-sizing: border-box !important;
    background: white !important;
    border: 1px solid #e0e0e0 !important;
    border-radius: 6px !important;
    display: flex !important;
    align-items: center !important;
}

.input-row {
    display: flex !important;
    align-items: center !important;
    gap: 0px !important;
    width: 100% !important;
    height: 100% !important;
    box-sizing: border-box !important;
    padding: 0 10px 0 0;
}

.chat-input-wrapper {
    flex: 1 !important;
    height: 100% !important;
    box-sizing: border-box !important;
    margin: 0 !important;
    padding: 0 !important;
    border: none !important;
    position: relative !important;
    display: flex !important;
    align-items: center !important;
}

.chat-input-wrapper textarea {
    width: 100% !important;
    height: 90px !important;
    min-height: 90px !important;
    max-height: 90px !important;
    box-sizing: border-box !important;
    resize: none !important;
    padding: 10px 14px !important;
    line-height: 1.4 !important;
    background: #f9f9f9 !important;
    border: 1px solid #d0d0d0 !important;
    border-radius: 6px !important;
    font-family: inherit !important;
    font-size: 14px !important;
    transition: all 0.2s ease !important;
    margin: 0 !important;
    display: block !important;
    overflow: hidden !important;
}

.chat-input-wrapper textarea:hover {
    border-color: #b0b0b0 !important;
    background: #f5f5f5 !important;
}

.chat-input-wrapper textarea:focus {
    border-color: #007bff !important;
    background: #fff !important;
    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1) !important;
    outline: none !important;
}

.send-btn-wrapper {
    height: 90px !important;
    width: 120px !important;
    min-width: 120px !important;
    max-width: 120px !important;
    flex-shrink: 0 !important;
    box-sizing: border-box !important;
    margin: 0 !important;
    padding: 0 !important;
    display: flex !important;
    align-items: center !important;
}

.send-btn-wrapper button {
    width: 100% !important;
    height: 90px !important;
    margin: 0 !important;
    padding: 12px 8px !important;
    border-radius: 6px !important;
    font-size: 14px !important;
    font-weight: 500 !important;
    background: #007bff !important;
    border: none !important;
    color: white !important;
    cursor: pointer !important;
    transition: all 0.2s ease !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    line-height: 1.2 !important;
    text-align: center !important;
    white-space: normal !important;
    word-wrap: break-word !important;
}

.send-btn-wrapper button:hover {
    background: #0056b3 !important;
    №transform: translateY(-1px) !important;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
}

.send-btn-wrapper button:active {
    transform: translateY(0) !important;
    box-shadow: none !important;
}

.send-btn-wrapper button:disabled {
    background: #cccccc !important;
    cursor: not-allowed !important;
    transform: none !important;
    box-shadow: none !important;
}
================================================================================
### css/sidebar.css
================================================================================

/* css/sidebar.css - Стили сайдбара */
#sidebar_container {
    height: 100vh !important;
    max-height: 100vh !important;
    overflow-y: auto !important;
    padding: 10px 15px !important;
    border-right: 1px solid #e0e0e0 !important;
    background: #f8f9fa !important;
    min-width: 300px !important;
    width: 300px !important;
    max-width: 350px !important;
    flex-shrink: 0 !important;
    position: relative !important;
    z-index: 10 !important;
}

/* Жесткий переопределение Gradio */
#sidebar_container .gr-dropdown {
    margin-top: 0 !important;
    margin-bottom: 15px !important;
    width: 100% !important;
    background: white !important;
    border: 1px solid #d0d0d0 !important;
    border-radius: 6px !important;
}

#sidebar_container .gr-dropdown:hover {
    border-color: #b0b0b0 !important;
}

#sidebar_container .gr-dropdown:focus {
    border-color: #007bff !important;
    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1) !important;
}

/* Кнопки в сайдбаре */
#sidebar_container .gr-button {
    margin: 5px 0 !important;
    width: 100% !important;
    padding: 10px 16px !important;
    font-size: 14px !important;
    font-weight: 500 !important;
}

#sidebar_container .gr-button.primary {
    background: #007bff !important;
    color: white !important;
}

#sidebar_container .gr-button.primary:hover {
    background: #0056b3 !important;
    transform: translateY(-1px) !important;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
}

#sidebar_container .gr-button.secondary {
    background: #6c757d !important;
    color: white !important;
}

#sidebar_container .gr-button.stop {
    background: #dc3545 !important;
    color: white !important;
}

/* Разделитель в сайдбаре */
.sidebar-divider {
    margin: 15px 0 !important;
    border-color: #e0e0e0 !important;
    border-width: 1px !important;
}

/* Аккордеон параметров */
#sidebar_container .params-accordion {
    margin-top: 15px !important;
    margin-bottom: 15px !important;
    background: white !important;
    border: 1px solid #e0e0e0 !important;
    border-radius: 8px !important;
    padding: 0 !important;
}

#sidebar_container .params-accordion .gr-accordion {
    border: none !important;
}

/* Слайдеры */
#sidebar_container .gr-slider {
    margin: 10px 0 !important;
}

#sidebar_container .gr-slider .gr-slider-input {
    background: #e9ecef !important;
}

#sidebar_container .gr-slider .gr-slider-input::-webkit-slider-thumb {
    background: #007bff !important;
}

/* Статус внизу сайдбара */
#sidebar_container .gr-markdown:last-child {
    margin-top: auto !important;
    margin-bottom: 10px !important;
    padding: 10px !important;
    background: white !important;
    border-radius: 6px !important;
    border: 1px solid #e0e0e0 !important;
}
================================================================================
### logic/ui_handlers.py
================================================================================

# /logic/ui_handlers.py
import gradio as gr
from container import container

class UIHandlers:
    """Обработчики UI событий"""
    
    def __init__(self):
        # Ленивая загрузка сервисов
        self._chat_service = None
        self._dialog_service = None
        self._config = None
    
    @property
    def chat_service(self):
        if self._chat_service is None:
            self._chat_service = container.get_chat_service()
        return self._chat_service
    
    @property
    def dialog_service(self):
        if self._dialog_service is None:
            self._dialog_service = container.get_dialog_service()
        return self._dialog_service
    
    @property
    def config(self):
        if self._config is None:
            self._config = container.get_config()
        return self._config
    
    def get_dialog_list_for_dropdown(self):
        """Получает список чатов для обновления dropdown"""
        dialogs = self.dialog_service.get_dialog_list()
        chat_names = [f"{d['name']} ({d['id']})" for d in dialogs]
        
        current_dialog = self.dialog_service.get_current_dialog()
        if current_dialog and chat_names:
            current_dialog_id = current_dialog.id
            # Находим индекс текущего диалога
            current_index = 0
            for i, d in enumerate(dialogs):
                if d["id"] == current_dialog_id:
                    current_index = i
                    break
            return gr.update(choices=chat_names, value=chat_names[current_index])
        return gr.update(choices=chat_names)
    
    def get_chat_name_from_selection(self, selection=None):
        """Получает название чата из выбранного элемента dropdown"""
        if selection:
            try:
                chat_name = selection.split("(")[0].strip()
                return chat_name
            except:
                return "Чат"
        elif self.dialog_service.current_dialog_id:
            dialog = self.dialog_service.get_current_dialog()
            if dialog:
                return dialog.name
        return "Чат"
    
    def create_chat_handler(self):
        """Обработчик создания нового чата"""
        try:
            dialog_id = self.dialog_service.create_dialog()
            
            dialogs = self.dialog_service.get_dialog_list()
            chat_names = [f"{d['name']} ({d['id']})" for d in dialogs]
            
            current_index = 0
            for i, d in enumerate(dialogs):
                if d["id"] == dialog_id:
                    current_index = i
                    break
            
            dialog = self.dialog_service.get_dialog(dialog_id)
            chat_name = dialog.name if dialog else "Новый чат"
            
            return [], "", dialog_id, gr.update(choices=chat_names, value=chat_names[current_index]), f"✅ Создан чат: {chat_name}", gr.update(label=chat_name)
        except Exception as e:
            print(f"Ошибка при создании чата: {e}")
            return [], "", None, gr.update(), f"⚠️ Ошибка: {str(e)}", gr.update()
    
    def switch_chat_handler(self, selection):
        """Обработчик переключения чата"""
        try:
            if not selection:
                return [], "", None, gr.update(), "⚠️ Выберите чат", gr.update()
            
            dialog_id = selection.split("(")[-1].rstrip(")")
            
            if self.dialog_service.switch_dialog(dialog_id):
                dialog = self.dialog_service.get_dialog(dialog_id)
                history = self.chat_service.get_chat_history(dialog_id)
                
                dialogs = self.dialog_service.get_dialog_list()
                chat_names = [f"{d['name']} ({d['id']})" for d in dialogs]
                
                current_index = 0
                for i, d in enumerate(dialogs):
                    if d["id"] == dialog_id:
                        current_index = i
                        break
                
                chat_name = dialog.name if dialog else "Чат"
                return history, "", dialog_id, gr.update(choices=chat_names, value=chat_names[current_index]), f"✅ Переключено на: {chat_name}", gr.update(label=chat_name)
            
            return [], "", None, gr.update(), "⚠️ Ошибка переключения чата", gr.update()
        except Exception as e:
            print(f"Ошибка при переключении чата: {e}")
            return [], "", None, gr.update(), f"⚠️ Ошибка: {str(e)}", gr.update()
    
    def delete_chat_handler(self, selection):
        """Обработчик удаления чата"""
        try:
            if not selection:
                return [], "", None, gr.update(), "⚠️ Выберите чат для удаления", gr.update()
            
            dialog_id = selection.split("(")[-1].rstrip(")")
            
            dialog = self.dialog_service.get_dialog(dialog_id)
            if not dialog:
                return [], "", None, gr.update(), "⚠️ Чат не найден", gr.update()
            
            dialog_name = dialog.name
            
            if self.dialog_service.delete_dialog(dialog_id):
                dialogs = self.dialog_service.get_dialog_list()
                chat_names = [f"{d['name']} ({d['id']})" for d in dialogs] if dialogs else []
                
                if dialogs:
                    current_index = 0
                    new_dialog_id = dialogs[0]["id"]
                    history = self.chat_service.get_chat_history(new_dialog_id)
                    dropdown_value = chat_names[current_index]
                    chat_name = dialogs[0]["name"]
                else:
                    current_index = 0
                    new_dialog_id = None
                    history = []
                    dropdown_value = None
                    chat_name = "Чат"
                
                return history, "", new_dialog_id, gr.update(choices=chat_names, value=dropdown_value), f"✅ Удален чат: {dialog_name}", gr.update(label=chat_name)
            
            return [], "", None, gr.update(), "⚠️ Ошибка удаления чата", gr.update()
        except Exception as e:
            print(f"Ошибка при удалении чата: {e}")
            return [], "", None, gr.update(), f"⚠️ Ошибка: {str(e)}", gr.update()
    
    def send_message_handler(self, prompt, chat_id, max_tokens, temperature):
        """Обработчик отправки сообщения"""
        try:
            if not prompt.strip():
                # Возвращаем ТОЛЬКО 5 значений
                return [], "", chat_id or "", gr.update(), gr.update()
            
            # Получаем или создаем диалог
            if not chat_id:
                chat_id = self.dialog_service.create_dialog()
            
            # Обрабатываем сообщение
            history, _, new_chat_id = self.chat_service.process_message(
                prompt, chat_id, max_tokens, temperature
            )
            
            # Обновляем список чатов
            dialogs = self.dialog_service.get_dialog_list()
            chat_names = [f"{d['name']} ({d['id']})" for d in dialogs]
            
            # Находим индекс текущего чата
            current_index = 0
            for i, d in enumerate(dialogs):
                if d["id"] == new_chat_id:
                    current_index = i
                    break
            
            chat_name = self.get_chat_name_from_selection(chat_names[current_index])
            
            # Возвращаем ТОЛЬКО 5 значений
            return history, "", new_chat_id, gr.update(choices=chat_names, value=chat_names[current_index]), gr.update(label=chat_name)
        
        except Exception as e:
            print(f"Ошибка при отправке сообщения: {e}")
            # Возвращаем ТОЛЬКО 5 значений
            return [], "", chat_id or "", gr.update(), gr.update()
    
    def init_app_handler(self):
        """Обработчик инициализации приложения"""
        try:
            # Создаем первый чат, если нет существующих
            if not self.dialog_service.dialogs:
                chat_id = self.dialog_service.create_dialog()
            else:
                chat_id = self.dialog_service.current_dialog_id
            
            # Получаем историю текущего чата
            history = self.chat_service.get_chat_history(chat_id)
            
            # Получаем обновленный список чатов для dropdown
            dropdown = self.get_dialog_list_for_dropdown()
            chat_name = self.get_chat_name_from_selection(dropdown["value"])
            
            return history, chat_id, dropdown, gr.update(label=chat_name)
        except Exception as e:
            print(f"Ошибка при инициализации приложения: {e}")
            return [], None, gr.update(), gr.update()

# Глобальный экземпляр
ui_handlers = UIHandlers()
================================================================================
### models/config_models.py
================================================================================

# /models/config_models.py
from pydantic import BaseModel, Field, validator
from typing import List, Optional, Dict, Any
from enum import Enum

class ModelDtype(str, Enum):
    AUTO = "auto"
    FLOAT16 = "float16"
    BFLOAT16 = "bfloat16"

class AppConfig(BaseModel):
    """Конфигурация приложения"""
    name: str = "Qwen3-4B Chat"
    version: str = "1.0.0"
    debug: bool = False
    theme: str = "soft"

class ServerConfig(BaseModel):
    """Конфигурация сервера"""
    host: str = "0.0.0.0"
    port: int = 7860
    share: bool = False
    show_error: bool = True

class QueueConfig(BaseModel):
    """Конфигурация очереди"""
    max_size: int = 5
    concurrency_limit: int = 1

class DialogConfig(BaseModel):
    """Конфигурация диалогов"""
    save_dir: str = "saved_dialogs"
    default_name: str = "Новый чат"

class ModelConfig(BaseModel):
    """Конфигурация модели"""
    name: str = "Qwen/Qwen3-4B"
    dtype: ModelDtype = ModelDtype.BFLOAT16
    attn_implementation: str = "eager"
    low_cpu_mem_usage: bool = True

class GenerationConfig(BaseModel):
    """Конфигурация генерации"""
    default_max_tokens: int = Field(512, ge=1, le=4096)
    default_temperature: float = Field(0.7, ge=0.1, le=2.0)
    default_top_p: float = Field(0.9, ge=0.0, le=1.0)
    default_repetition_penalty: float = Field(1.1, ge=1.0, le=2.0)
    
    min_max_tokens: int = 64
    max_max_tokens: int = 2048
    min_temperature: float = 0.1
    max_temperature: float = 1.5

class ChatNamingConfig(BaseModel):
    """Конфигурация генерации названий чатов"""
    max_name_length: int = 50
    summary_max_tokens: int = 20
    summary_temperature: float = 0.4

class UIConfig(BaseModel):
    """Конфигурация UI"""
    class SidebarConfig(BaseModel):
        width: str = "300px"
        min_width: str = "300px"
        max_width: str = "350px"
        background: str = "#f8f9fa"
        border_color: str = "#e0e0e0"
    
    class ChatWindowConfig(BaseModel):
        background: str = "white"
        border_color: str = "#e0e0e0"
        border_radius: str = "8px"
        padding: str = "12px"
    
    class InputAreaConfig(BaseModel):
        height: str = "110px"
        min_height: str = "110px"
        max_height: str = "110px"
        background: str = "white"
        border_color: str = "#e0e0e0"
        border_radius: str = "6px"
    
    class ButtonsConfig(BaseModel):
        primary_color: str = "#007bff"
        primary_hover: str = "#0056b3"
        secondary_color: str = "#6c757d"
        danger_color: str = "#dc3545"
    
    class TextConfig(BaseModel):
        font_family: str = "inherit"
        font_size: str = "14px"
        line_height: str = "1.4"
    
    class MessagesConfig(BaseModel):
        user_bg: str = "#e3f2fd"
        user_border: str = "#bbdefb"
        bot_bg: str = "#f5f5f5"
        bot_border: str = "#e0e0e0"
        max_width: str = "75%"
        border_radius: str = "12px"
        padding: str = "10px 14px"
    
    sidebar: SidebarConfig = SidebarConfig()
    chat_window: ChatWindowConfig = ChatWindowConfig()
    input_area: InputAreaConfig = InputAreaConfig()
    buttons: ButtonsConfig = ButtonsConfig()
    text: TextConfig = TextConfig()
    messages: MessagesConfig = MessagesConfig()

class PathsConfig(BaseModel):
    """Конфигурация путей"""
    css_dir: str = "css"
    saved_dialogs: str = "saved_dialogs"
    logs: str = "logs"
    css_files: List[str] = Field(default_factory=list)
    
    @validator('css_files', pre=True, always=True)
    def set_css_files(cls, v):
        if not v:
            return [
                "css/base.css",
                "css/sidebar.css",
                "css/chat_window.css",
                "css/input_area.css"
            ]
        return v

class FullConfig(BaseModel):
    """Полная конфигурация приложения"""
    app: AppConfig = AppConfig()
    server: ServerConfig = ServerConfig()
    queue: QueueConfig = QueueConfig()
    dialogs: DialogConfig = DialogConfig()
    model: ModelConfig = ModelConfig()
    generation: GenerationConfig = GenerationConfig()
    chat_naming: ChatNamingConfig = ChatNamingConfig()
    ui: UIConfig = UIConfig()
    paths: PathsConfig = PathsConfig()
================================================================================
### models/dialog.py
================================================================================

# /models/dialog.py
from pydantic import BaseModel, Field, ConfigDict
from datetime import datetime
from typing import List, Optional, Dict, Any
from .enums import MessageRole
from .message import Message

class Dialog(BaseModel):
    """Модель диалога"""
    
    model_config = ConfigDict(
        json_encoders={
            datetime: lambda v: v.isoformat()
        }
    )
    
    id: str
    name: str
    history: List[Message] = []
    created: datetime = Field(default_factory=datetime.now)
    updated: datetime = Field(default_factory=datetime.now)
    status: str = "active"
    
    def add_message(self, role: MessageRole, content: str) -> Message:
        """Добавляет сообщение в диалог и возвращает его"""
        message = Message(role=role, content=content)
        self.history.append(message)
        self.updated = datetime.now()
        return message
    
    def clear_history(self):
        """Очищает историю диалога"""
        self.history = []
        self.updated = datetime.now()
    
    def rename(self, new_name: str):
        """Переименовывает диалог"""
        self.name = new_name
        self.updated = datetime.now()
    
    def get_last_message(self) -> Optional[Message]:
        """Получает последнее сообщение в диалоге"""
        if self.history:
            return self.history[-1]
        return None
    
    def get_message_count(self) -> int:
        """Получает количество сообщений"""
        return len(self.history)
    
    def to_ui_format(self) -> List[Dict[str, str]]:
        """Конвертирует диалог в формат для UI (Gradio Chatbot)"""
        return [
            {"role": msg.role.value, "content": msg.content}
            for msg in self.history
        ]
    
    def get_summary(self, max_length: int = 100) -> str:
        """Получает краткое описание диалога"""
        if not self.history:
            return "Пустой диалог"
        
        # Пытаемся взять последнее сообщение пользователя
        for msg in reversed(self.history):
            if msg.role == MessageRole.USER:
                content = msg.content
                if len(content) > max_length:
                    return content[:max_length] + "..."
                return content
        
        # Если нет сообщений пользователя, берем любое
        last_msg = self.history[-1]
        content = last_msg.content
        if len(content) > max_length:
            return content[:max_length] + "..."
        return content
    
    def dict(self, *args, **kwargs) -> Dict[str, Any]:
        """Переопределяем dict для правильной сериализации"""
        return self.json_serialize()

    def json_serialize(self) -> Dict[str, Any]:
        """Сериализует диалог в JSON-совместимый словарь"""
        return {
            "id": self.id,
            "name": self.name,
            "history": [
                {
                    "role": msg.role.value,
                    "content": msg.content,
                    "timestamp": msg.timestamp.isoformat()
                }
                for msg in self.history
            ],
            "created": self.created.isoformat(),
            "updated": self.updated.isoformat(),
            "status": self.status
        }
================================================================================
### models/enums.py
================================================================================

# /models/enums.py
from enum import Enum

class MessageRole(str, Enum):
    USER = "user"
    ASSISTANT = "assistant"
    SYSTEM = "system"

class DialogStatus(str, Enum):
    ACTIVE = "active"
    ARCHIVED = "archived"
    DELETED = "deleted"
================================================================================
### models/message.py
================================================================================

# /models/message.py
from pydantic import BaseModel, Field, ConfigDict
from datetime import datetime
from .enums import MessageRole

class Message(BaseModel):
    """Модель сообщения в диалоге"""
    
    model_config = ConfigDict(
        json_encoders={
            datetime: lambda v: v.isoformat()
        }
    )
    
    role: MessageRole
    content: str
    timestamp: datetime = Field(default_factory=datetime.now)
    
    def json_serialize(self) -> dict:
        """Конвертирует сообщение в JSON-совместимый словарь"""
        return {
            "role": self.role.value,
            "content": self.content,
            "timestamp": self.timestamp.isoformat()
        }
    
    def dict(self, *args, **kwargs) -> Dict[str, Any]:
        """Переопределяем dict для правильной сериализации"""
        return self.json_serialize()
================================================================================
### requirements.txt
================================================================================

gradio=6.3.0
transformers>=4.35.0
torch>=2.0.0
accelerate>=0.24.0
PyYAML>=6.0
pydantic>=2.0.0

================================================================================
### run.py
================================================================================

# /run.py
import gradio as gr
from ui.main import create_main_ui  # Теперь возвращает (demo, css_content)
from container import container

def main():
    print("=" * 60)
    print("🚀 Запуск Qwen3-4B Chat")
    print("=" * 60)
    
    # Инициализация модели (с минимальным логированием)
    print("📦 Загрузка модели...")
    try:
        model_service = container.get_model_service()
        model, tokenizer, lock = model_service.initialize()
        # Не выводим дополнительных сообщений
    except Exception as e:
        print(f"⚠️ Предупреждение: {e}")
        print("ℹ️ Модель загрузится при первом запросе")
    
    # Создание интерфейса
    print("🖥️ Создание интерфейса...")
    demo, css_content = create_main_ui()  # ← Получаем и demo и css
    print("✅ Интерфейс создан")
    
    # Запуск приложения
    print("🌐 Запуск сервера...")
    print("=" * 60)
    
    config = container.get_config()
    
    demo.queue(
        max_size=config.queue.max_size,
        default_concurrency_limit=config.queue.concurrency_limit
    ).launch(
        server_name=config.server.host,
        server_port=config.server.port,
        share=config.server.share,
        debug=config.app.debug,
        show_error=config.server.show_error,
        theme=config.app.theme,
        css=css_content  # ← Передаем css в launch()
    )

if __name__ == "__main__":
    main()
================================================================================
### services/chat_service.py
================================================================================

# /services/chat_service.py
import re
import torch
from typing import Tuple, List, Dict, Any, Optional
from models.enums import MessageRole

class ChatService:
    """Сервис для логики чата"""
    
    def __init__(self):
        # Ленивый импорт container
        from container import container
        self.config = container.get_config()
        self.model_service = container.get_model_service()
        self.dialog_service = container.get_dialog_service()
    
    def initialize_model(self):
        """Инициализирует модель (ленивая загрузка)"""
        return self.model_service.initialize()
    
    def process_message(self, prompt: str, dialog_id: Optional[str] = None, 
                       max_tokens: Optional[int] = None,
                       temperature: Optional[float] = None) -> Tuple[List[Dict], str, str]:
        """Обрабатывает входящее сообщение и генерирует ответ"""
        if not prompt.strip():
            return [], "⚠️ Введите сообщение", dialog_id or ""
        
        # Получаем или создаем диалог
        if not dialog_id:
            dialog_id = self.dialog_service.create_dialog()
        
        # Получаем модель и токенизатор
        model, tokenizer, generate_lock = self.initialize_model()
        
        # Получаем историю диалога
        dialog = self.dialog_service.get_dialog(dialog_id)
        if not dialog:
            return [], "Ошибка: диалог не найден", dialog_id
        
        # Проверяем, первое ли это сообщение
        is_first_message = len(dialog.history) == 0
        
        # Форматируем историю для модели
        formatted_history = []
        for msg in dialog.history:
            formatted_history.append({
                "role": msg.role.value,
                "content": msg.content
            })
        
        formatted_history.append({"role": "user", "content": prompt})
        
        # Подготавливаем текст для модели
        text = tokenizer.apply_chat_template(
            formatted_history,
            tokenize=False,
            add_generation_prompt=True
        )
        
        # Получаем параметры генерации
        gen_params = self.model_service.get_generation_params(
            max_tokens=max_tokens,
            temperature=temperature
        )
        
        # Генерируем ответ
        response_text = ""
        with generate_lock:
            inputs = tokenizer(text, return_tensors="pt").to(model.device)
            
            with torch.no_grad():
                outputs = model.generate(
                    **inputs,
                    **gen_params
                )
            
            input_length = inputs.input_ids.shape[1]
            response_text = tokenizer.decode(outputs[0][input_length:], skip_special_tokens=True)
        
        # Очищаем ответ
        response_text = self._clean_response(response_text)
        
        # Добавляем сообщения в диалог
        self.dialog_service.add_message(dialog_id, MessageRole.USER, prompt)
        self.dialog_service.add_message(dialog_id, MessageRole.ASSISTANT, response_text)
        
        # Если это первое сообщение, генерируем простое название
        if is_first_message:
            self._generate_chat_name_simple(dialog_id, prompt)
        
        # Получаем обновленную историю для отображения
        dialog = self.dialog_service.get_dialog(dialog_id)
        display_history = dialog.to_ui_format()
        
        return display_history, "", dialog_id
    
    def _clean_response(self, response: str) -> str:
        """Очищает ответ от служебных тегов"""
        # Убираем тег <think> и его содержимое
        think_pattern = r'<think>.*?</think>'
        response = re.sub(think_pattern, '', response, flags=re.DOTALL)
        
        # Убираем оставшиеся теги
        response = re.sub(r'<[^>]+>', '', response)
        
        # Очищаем лишние пробелы и переносы строк
        response = re.sub(r'\n\s*\n', '\n', response)
        return response.strip()
    
    def _generate_chat_name_simple(self, dialog_id: str, prompt: str):
        """Генерирует простое осмысленное название из промпта (1-4 слова)"""
        try:
            # Очищаем промпт от мусора
            clean_prompt = re.sub(r'[^\w\s]', ' ', prompt.lower())
            words = clean_prompt.split()
            
            # Убираем стоп-слова (слишком короткие и неинформативные)
            stop_words = {'привет', 'здравствуй', 'здравствуйте', 'здрасьте', 'хай', 'хелло', 'hello', 'hi',
                         'как', 'дела', 'что', 'ты', 'вы', 'мне', 'меня', 'мной', 'твой', 'ваш',
                         'это', 'тот', 'этот', 'такой', 'который', 'свой',
                         'можно', 'мог', 'могу', 'можешь', 'можете', 'помоги', 'помощь',
                         'пожалуйста', 'пжлст', 'плз', 'plz', 'спасибо', 'thanks', 'thank',
                         'ну', 'вот', 'так', 'же', 'бы', 'ли', 'то', 'либо', 'нибудь',
                         'а', 'и', 'но', 'или', 'да', 'нет', 'не', 'ни', 'же',
                         'уже', 'еще', 'уж', 'ещё', 'очень', 'оч', 'очень',
                         'хочу', 'хотел', 'хотела', 'хотелось', 'хотеть',
                         'сделай', 'напиши', 'объясни', 'расскажи', 'покажи',
                         'вопрос', 'ответ', 'информация', 'инфа', 'инфо'}
            
            meaningful_words = []
            for word in words[:10]:  # Берем первые 10 слов
                if (len(word) > 2 and  # Слово длиннее 2 букв
                    word not in stop_words and  # Не стоп-слово
                    word not in meaningful_words):  # Не дублируется
                    meaningful_words.append(word)
            
            # Формируем название
            if meaningful_words:
                if len(meaningful_words) > 4:
                    chat_name = ' '.join(meaningful_words[:4])
                else:
                    chat_name = ' '.join(meaningful_words)
            else:
                # Fallback: берем первые 3 слова из промпта
                chat_name = ' '.join(words[:3]) if len(words) >= 3 else prompt[:30]
            
            # Капитализируем первую букву
            chat_name = chat_name.strip().capitalize()
            
            # Обрезаем если слишком длинное
            if len(chat_name) > 50:
                chat_name = chat_name[:47] + '...'
            
            # Обновляем название диалога
            self.dialog_service.rename_dialog(dialog_id, chat_name)
            print(f"✅ Название чата: {chat_name}")
            
        except Exception as e:
            print(f"⚠️ Ошибка при генерации названия: {e}")
            # Простой fallback
            simple_name = prompt[:40] + ('...' if len(prompt) > 40 else '')
            self.dialog_service.rename_dialog(dialog_id, simple_name)
    
    def get_chat_history(self, dialog_id: Optional[str] = None) -> List[Dict]:
        """Получает историю чата"""
        if not dialog_id:
            dialog = self.dialog_service.get_current_dialog()
        else:
            dialog = self.dialog_service.get_dialog(dialog_id)
        
        if dialog:
            return dialog.to_ui_format()
        return []

# Глобальный экземпляр
chat_service = ChatService()
================================================================================
### services/config_service.py
================================================================================

# /services/config_service.py
import yaml
import os
from typing import Dict, Any, Optional
from models.config_models import FullConfig

class ConfigService:
    """Сервис для работы с конфигурацией"""
    
    def __init__(self, config_dir: str = "config"):
        self.config_dir = config_dir
        self._config: Optional[FullConfig] = None
    
    def load_config(self) -> FullConfig:
        """Загружает конфигурацию из YAML файлов"""
        config_data = {}
        
        # Загружаем все YAML файлы
        yaml_files = [
            "app_config.yaml",
            "model_config.yaml", 
            "ui_config.yaml",
            "paths_config.yaml"
        ]
        
        for yaml_file in yaml_files:
            file_path = os.path.join(self.config_dir, yaml_file)
            if os.path.exists(file_path):
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_config = yaml.safe_load(f)
                    self._merge_dicts(config_data, file_config)
            else:
                print(f"⚠️ Конфиг файл не найден: {file_path}")
        
        # Создаем Pydantic модель
        self._config = FullConfig(**config_data)
        return self._config
    
    def get_config(self) -> FullConfig:
        """Получает конфигурацию (загружает если нужно)"""
        if self._config is None:
            return self.load_config()
        return self._config
    
    def save_config(self, config: FullConfig, config_dir: str = None):
        """Сохраняет конфигурацию в YAML файлы"""
        if config_dir is None:
            config_dir = self.config_dir
        
        # Конвертируем модель в словарь
        config_dict = config.dict()
        
        # Сохраняем в разные файлы
        yaml_structure = {
            "app_config.yaml": {
                "app": config_dict.get("app", {}),
                "server": config_dict.get("server", {}),
                "queue": config_dict.get("queue", {}),
                "dialogs": config_dict.get("dialogs", {})
            },
            "model_config.yaml": {
                "model": config_dict.get("model", {}),
                "generation": config_dict.get("generation", {}),
                "chat_naming": config_dict.get("chat_naming", {})
            },
            "ui_config.yaml": {
                "ui": config_dict.get("ui", {})
            },
            "paths_config.yaml": {
                "paths": config_dict.get("paths", {})
            }
        }
        
        for filename, data in yaml_structure.items():
            file_path = os.path.join(config_dir, filename)
            with open(file_path, 'w', encoding='utf-8') as f:
                yaml.dump(data, f, default_flow_style=False, allow_unicode=True, indent=2)
    
    def _merge_dicts(self, target: Dict[str, Any], source: Dict[str, Any]):
        """Рекурсивно мержит словари"""
        for key, value in source.items():
            if key in target and isinstance(target[key], dict) and isinstance(value, dict):
                self._merge_dicts(target[key], value)
            else:
                target[key] = value
    
    def reload(self) -> FullConfig:
        """Перезагружает конфигурацию"""
        self._config = None
        return self.load_config()
    
    def get_css_content(self) -> str:
        """Получает CSS контент"""
        # Можно добавить кэширование здесь
        from services.css_generator import css_generator
        return css_generator.load_existing_css()

# Глобальный экземпляр конфиг сервиса
config_service = ConfigService()
================================================================================
### services/css_generator.py
================================================================================

# /services/css_generator.py
import os
from typing import Dict, Any

class CSSGenerator:
    """Генератор CSS из конфигурации"""
    
    def __init__(self):
        # Ленивый импорт container
        from container import container
        self.config = container.get_config().ui
        self.paths_config = container.get_config().paths
    
    def generate_css(self) -> str:
        """Генерирует полный CSS код из конфигов"""
        css_parts = []
        
        # Базовые стили из конфига
        css_parts.append(self._generate_base_css())
        
        # Стили сайдбара
        css_parts.append(self._generate_sidebar_css())
        
        # Стили окна чата
        css_parts.append(self._generate_chat_window_css())
        
        # Стили области ввода
        css_parts.append(self._generate_input_area_css())
        
        # Собираем все вместе
        full_css = "\n".join(css_parts)
        
        # Сохраняем в файл (для отладки)
        self._save_css_to_file(full_css)
        
        return full_css
    
    def _generate_base_css(self) -> str:
        """Генерирует базовые стили"""
        return f"""
/* Авто-сгенерированный CSS из конфигурации */
/* Базовые сбросы и общие стили */

* {{
    box-sizing: border-box !important;
}}

body, html, .gradio-container {{
    margin: 0 !important;
    padding: 0 !important;
    height: 100vh !important;
    width: 100vw !important;
    overflow: hidden !important;
}}

/* Основной контейнер - жесткий контроль */
.gradio-container, 
.gradio-container > div,
.gradio-container > div > div {{
    height: 100vh !important;
    max-height: 100vh !important;
    min-height: 100vh !important;
}}

/* Основной ряд - занимает всю высоту */
.main-row {{
    height: 100vh !important;
    max-height: 100vh !important;
    min-height: 100vh !important;
    margin: 0 !important;
    padding: 0 !important;
    flex-wrap: nowrap !important;
}}

/* Основной контент - занимает оставшееся */
.main-content {{
    height: 100vh !important;
    max-height: 100vh !important;
    min-height: 100vh !important;
    padding: 0 !important;
    margin: 0 !important;
    flex: 1 !important;
    min-width: 0 !important;
    display: flex !important;
    flex-direction: column !important;
}}

/* Главный контейнер чата */
.chat-main-container {{
    height: calc(100vh - 20px) !important;
    max-height: calc(100vh - 20px) !important;
    min-height: calc(100vh - 20px) !important;
    padding: {self.config.chat_window.padding} !important;
    display: flex !important;
    flex-direction: column !important;
    flex: 1 !important;
    min-height: 0 !important;
    gap: 8px !important;
}}

/* Убираем стандартные стили Gradio */
.gr-box, .gr-form {{
    border: none !important;
    margin: 0 !important;
    padding: 0 !important;
}}

/* Фикс для flex элементов */
.wrap, .wrap.column {{
    height: auto !important;
    min-height: 0 !important;
    margin: 0 !important;
    padding: 0 !important;
}}

/* Убираем лишние отступы у Gradio элементов */
.gr-column, .gr-row {{
    margin: 0 !important;
    padding: 0 !important;
}}

/* Убираем outline у всех элементов при фокусе */
*:focus {{
    outline: none !important;
}}

/* Базовые настройки текста */
body {{
    font-family: {self.config.text.font_family} !important;
    font-size: {self.config.text.font_size} !important;
    line-height: {self.config.text.line_height} !important;
}}
"""
    
    def _generate_sidebar_css(self) -> str:
        """Генерирует стили сайдбара"""
        sidebar = self.config.sidebar
        
        return f"""
/* Стили сайдбара - сгенерировано из конфига */

#sidebar_container {{
    height: 100vh !important;
    max-height: 100vh !important;
    overflow-y: auto !important;
    padding: 10px 15px !important;
    border-right: 1px solid {sidebar.border_color} !important;
    background: {sidebar.background} !important;
    min-width: {sidebar.min_width} !important;
    width: {sidebar.width} !important;
    max-width: {sidebar.max_width} !important;
    flex-shrink: 0 !important;
}}

/* Разделитель в сайдбаре */
.sidebar-divider {{
    margin: 15px 0 !important;
    border-color: {sidebar.border_color} !important;
}}

/* Dropdown в сайдбаре */
#sidebar_container .gr-dropdown {{
    margin-top: 0 !important;
    margin-bottom: 15px !important;
}}

/* Кнопки в сайдбаре */
#sidebar_container .gr-button {{
    margin: 5px 0 !important;
}}

/* Аккордеон параметров */
#sidebar_container .params-accordion {{
    margin-top: 15px !important;
    margin-bottom: 15px !important;
}}

/* Статус внизу сайдбара */
#sidebar_container .gr-markdown:last-child {{
    margin-top: auto !important;
    margin-bottom: 10px !important;
}}

/* Стили кнопок из конфига */
.primary-btn {{
    background: {self.config.buttons.primary_color} !important;
    border: none !important;
    color: white !important;
}}

.primary-btn:hover {{
    background: {self.config.buttons.primary_hover} !important;
}}

.secondary-btn {{
    background: {self.config.buttons.secondary_color} !important;
    border: none !important;
    color: white !important;
}}

.danger-btn {{
    background: {self.config.buttons.danger_color} !important;
    border: none !important;
    color: white !important;
}}
"""
    
    def _generate_chat_window_css(self) -> str:
        """Генерирует стили окна чата"""
        chat = self.config.chat_window
        messages = self.config.messages
        
        return f"""
/* Стили окна чата - сгенерировано из конфига */

.chat-window-container {{
    flex: 1 !important;
    min-height: 0 !important;
    overflow-y: auto !important;
    border: 1px solid {chat.border_color} !important;
    border-radius: {chat.border_radius} !important;
    background: {chat.background} !important;
    box-sizing: border-box !important;
    padding: {chat.padding} !important;
}}

/* Чатбот */
.chat-window-container .chatbot {{
    display: flex !important;
    flex-direction: column !important;
    gap: 12px !important;
    margin: 0 !important;
    padding: 0 !important;
    border: none !important;
    background: transparent !important;
}}

/* Контейнеры сообщений */
.chat-window-container .chatbot > div {{
    margin: 0 !important;
    padding: 0 !important;
    border: none !important;
    display: flex !important;
    width: 100% !important;
    min-height: auto !important;
    height: auto !important;
}}

/* СООБЩЕНИЯ ПОЛЬЗОВАТЕЛЯ */
.chat-window-container .message.user {{
    background-color: {messages.user_bg} !important;
    border: 1px solid {messages.user_border} !important;
    border-radius: {messages.border_radius} {messages.border_radius} 0 {messages.border_radius} !important;
    padding: {messages.padding} !important;
    margin-left: auto !important;
    margin-right: 0 !important;
    max-width: {messages.max_width} !important;
    min-width: fit-content !important;
    word-wrap: break-word !important;
    white-space: pre-wrap !important;
    line-height: 1.4 !important;
    margin-bottom: 0 !important;
    padding-bottom: 10px !important;
    display: inline-block !important;
    position: relative !important;
}}

/* СООБЩЕНИЯ АССИСТЕНТА */
.chat-window-container .message.bot {{
    background-color: {messages.bot_bg} !important;
    border: 1px solid {messages.bot_border} !important;
    border-radius: {messages.border_radius} {messages.border_radius} {messages.border_radius} 0 !important;
    padding: {messages.padding} !important;
    margin-left: 0 !important;
    margin-right: auto !important;
    max-width: {messages.max_width} !important;
    min-width: fit-content !important;
    word-wrap: break-word !important;
    white-space: pre-wrap !important;
    line-height: 1.4 !important;
    margin-bottom: 0 !important;
    padding-bottom: 10px !important;
    display: inline-block !important;
    position: relative !important;
}}

/* КОНТЕЙНЕРЫ для разных типов */
.chat-window-container .chatbot > div[data-testid="user"] {{
    justify-content: flex-end !important;
    align-items: flex-start !important;
}}

.chat-window-container .chatbot > div[data-testid="bot"] {{
    justify-content: flex-start !important;
    align-items: flex-start !important;
}}

/* ВНУТРЕННИЕ ЭЛЕМЕНТЫ сообщений */
.chat-window-container .message {{
    display: inline-block !important;
    position: relative !important;
}}

/* Текст в сообщениях */
.chat-window-container .message p {{
    margin: 0 0 4px 0 !important;
    line-height: 1.4 !important;
    word-break: break-word !important;
}}

.chat-window-container .message p:last-child {{
    margin-bottom: 0 !important;
}}

/* Убираем пустые элементы */
.chat-window-container .message p:empty:not(:has(*)) {{
    display: none !important;
}}

/* Аватары */
.chat-window-container .avatar {{
    width: 32px !important;
    height: 32px !important;
    min-width: 32px !important;
    min-height: 32px !important;
    margin: 0 8px !important;
    align-self: flex-start !important;
}}

/* Стили для скроллбара чата */
.chat-window-container::-webkit-scrollbar {{
    width: 8px !important;
}}

.chat-window-container::-webkit-scrollbar-track {{
    background: #f8f9fa !important;
    border-radius: 4px !important;
}}

.chat-window-container::-webkit-scrollbar-thumb {{
    background: #ced4da !important;
    border-radius: 4px !important;
}}

.chat-window-container::-webkit-scrollbar-thumb:hover {{
    background: #adb5bd !important;
}}

/* ФИКС для Gradio контейнеров */
.chatbot .wrap.s {{
    margin: 0 !important;
    padding: 0 !important;
}}

.chat-window-container .chatbot > div .wrap,
.chat-window-container .chatbot > div .wrap.s,
.chat-window-container .chatbot > div .wrap.s.column {{
    margin: 0 !important;
    padding: 0 !important;
    gap: 0 !important;
    border: none !important;
}}

/* Просто скрываем ВСЕ кнопки с классом icon-button */
.chatbot .icon-button,
.chatbot button.icon-button {{
    display: none !important;
}}
"""
    
    def _generate_input_area_css(self) -> str:
        """Генерирует стили области ввода"""
        input_area = self.config.input_area
        
        return f"""
/* Стили области ввода - сгенерировано из конфига */

.input-plate {{
    flex-shrink: 0 !important;
    height: {input_area.height} !important;
    min-height: {input_area.min_height} !important;
    max-height: {input_area.max_height} !important;
    box-sizing: border-box !important;
    background: {input_area.background} !important;
    border: 1px solid {input_area.border_color} !important;
    border-radius: {input_area.border_radius} !important;
    display: flex !important;
    align-items: center !important;
}}

.input-row {{
    display: flex !important;
    align-items: center !important;
    gap: 0px !important;
    width: 100% !important;
    height: 100% !important;
    box-sizing: border-box !important;
    padding: 0 10px 0 0;
}}

.chat-input-wrapper {{
    flex: 1 !important;
    height: 100% !important;
    box-sizing: border-box !important;
    margin: 0 !important;
    padding: 0 !important;
    border: none !important;
    position: relative !important;
    display: flex !important;
    align-items: center !important;
}}

.chat-input-wrapper textarea {{
    width: 100% !important;
    height: 90px !important;
    min-height: 90px !important;
    max-height: 90px !important;
    box-sizing: border-box !important;
    resize: none !important;
    padding: 10px 14px !important;
    line-height: 1.4 !important;
    background: #f9f9f9 !important;
    border: 1px solid #d0d0d0 !important;
    border-radius: 6px !important;
    font-family: inherit !important;
    font-size: 14px !important;
    transition: all 0.2s ease !important;
    margin: 0 !important;
    display: block !important;
    overflow: hidden !important;
}}

.chat-input-wrapper textarea:hover {{
    border-color: #b0b0b0 !important;
    background: #f5f5f5 !important;
}}

.chat-input-wrapper textarea:focus {{
    border-color: {self.config.buttons.primary_color} !important;
    background: #fff !important;
    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1) !important;
    outline: none !important;
}}

.send-btn-wrapper {{
    height: 90px !important;
    width: 120px !important;
    min-width: 120px !important;
    max-width: 120px !important;
    flex-shrink: 0 !important;
    box-sizing: border-box !important;
    margin: 0 !important;
    padding: 0 !important;
    display: flex !important;
    align-items: center !important;
}}

.send-btn-wrapper button {{
    width: 100% !important;
    height: 90px !important;
    margin: 0 !important;
    padding: 12px 8px !important;
    border-radius: 6px !important;
    font-size: 14px !important;
    font-weight: 500 !important;
    background: {self.config.buttons.primary_color} !important;
    border: none !important;
    color: white !important;
    cursor: pointer !important;
    transition: all 0.2s ease !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    line-height: 1.2 !important;
    text-align: center !important;
    white-space: normal !important;
    word-wrap: break-word !important;
}}

.send-btn-wrapper button:hover {{
    background: {self.config.buttons.primary_hover} !important;
    transform: translateY(-1px) !important;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
}}

.send-btn-wrapper button:active {{
    transform: translateY(0) !important;
    box-shadow: none !important;
}}

.send-btn-wrapper button:disabled {{
    background: #cccccc !important;
    cursor: not-allowed !important;
    transform: none !important;
    box-shadow: none !important;
}}
"""
    
    def _save_css_to_file(self, css_content: str):
        """Сохраняет сгенерированный CSS в файл для отладки"""
        debug_css_path = "generated_styles.css"
        try:
            with open(debug_css_path, 'w', encoding='utf-8') as f:
                f.write("/* АВТОГЕНЕРИРОВАННЫЙ CSS - НЕ РЕДАКТИРОВАТЬ */\n")
                f.write("/* Редактируйте config/ui_config.yaml */\n\n")
                f.write(css_content)
            print(f"✅ CSS сохранен в {debug_css_path}")
        except Exception as e:
            print(f"⚠️ Не удалось сохранить CSS: {e}")
    
    def load_existing_css(self) -> str:
        """Загружает существующие CSS файлы (для обратной совместимости)"""
        css_content = ""
        
        for css_file in self.paths_config.css_files:
            try:
                if os.path.exists(css_file):
                    with open(css_file, 'r', encoding='utf-8') as f:
                        css_content += f.read() + "\n"
                else:
                    print(f"⚠️ CSS файл не найден: {css_file}")
            except Exception as e:
                print(f"⚠️ Ошибка загрузки CSS файла {css_file}: {e}")
        
        # Если нет файлов, генерируем из конфига
        if not css_content:
            css_content = self.generate_css()
        
        return css_content

# Глобальный экземпляр
css_generator = CSSGenerator()
================================================================================
### services/dialog_service.py
================================================================================

# /services/dialog_service.py
import json
import os
from datetime import datetime
from typing import List, Dict, Optional, Any
from models.dialog import Dialog, Message
from models.enums import MessageRole

class DialogService:
    """Сервис для управления диалогами"""
    
    def __init__(self):
        # Ленивый импорт container
        from container import container
        self.config = container.get_config().dialogs
        self.dialogs: Dict[str, Dialog] = {}
        self.current_dialog_id: Optional[str] = None
        self.next_dialog_id = 1
        
        # Создаем директорию для сохранения диалогов
        os.makedirs(self.config.save_dir, exist_ok=True)
        self.load_dialogs()
    
    def create_dialog(self, name: Optional[str] = None) -> str:
        """Создает новый диалог"""
        dialog_id = str(self.next_dialog_id)
        self.next_dialog_id += 1
        
        if not name:
            name = f"{self.config.default_name} {dialog_id}"
        
        dialog = Dialog(
            id=dialog_id,
            name=name,
            history=[],
            created=datetime.now(),
            updated=datetime.now()
        )
        
        self.dialogs[dialog_id] = dialog
        self.current_dialog_id = dialog_id
        self._save_dialog(dialog)  # Тихое сохранение
        
        return dialog_id
    
    def switch_dialog(self, dialog_id: str) -> bool:
        """Переключается на указанный диалог"""
        if dialog_id in self.dialogs:
            self.current_dialog_id = dialog_id
            return True
        return False
    
    def delete_dialog(self, dialog_id: str) -> bool:
        """Удаляет диалог"""
        if dialog_id in self.dialogs:
            # Удаляем файл с диалогом
            dialog_file = os.path.join(self.config.save_dir, f"dialog_{dialog_id}.json")
            if os.path.exists(dialog_file):
                os.remove(dialog_file)
            
            # Удаляем из памяти
            del self.dialogs[dialog_id]
            
            # Если удалили текущий диалог, переключаемся на другой
            if self.current_dialog_id == dialog_id:
                if self.dialogs:
                    self.current_dialog_id = list(self.dialogs.keys())[0]
                else:
                    self.current_dialog_id = None
            
            self._save_all_silent()  # Тихое сохранение
            return True
        return False
    
    def rename_dialog(self, dialog_id: str, new_name: str) -> bool:
        """Переименовывает диалог"""
        if dialog_id in self.dialogs:
            self.dialogs[dialog_id].rename(new_name)
            self._save_dialog(self.dialogs[dialog_id])  # Тихое сохранение
            return True
        return False
    
    def get_current_dialog(self) -> Optional[Dialog]:
        """Получает текущий активный диалог"""
        if self.current_dialog_id and self.current_dialog_id in self.dialogs:
            return self.dialogs[self.current_dialog_id]
        return None
    
    def get_dialog(self, dialog_id: str) -> Optional[Dialog]:
        """Получает диалог по ID"""
        return self.dialogs.get(dialog_id)
    
    def get_dialog_list(self) -> List[Dict[str, Any]]:
        """Получает список всех диалогов"""
        dialogs_list = []
        for dialog_id, dialog in self.dialogs.items():
            dialogs_list.append({
                "id": dialog_id,
                "name": dialog.name,
                "history_length": len(dialog.history),
                "created": dialog.created.isoformat(),
                "updated": dialog.updated.isoformat(),
                "is_current": (dialog_id == self.current_dialog_id)
            })
        
        # Сортируем по дате обновления (свежие сверху)
        dialogs_list.sort(key=lambda x: x["updated"], reverse=True)
        return dialogs_list
    
    def add_message(self, dialog_id: str, role: MessageRole, content: str) -> bool:
        """Добавляет сообщение в диалог"""
        if dialog_id in self.dialogs:
            self.dialogs[dialog_id].add_message(role, content)
            self._save_dialog(self.dialogs[dialog_id])  # Тихое сохранение
            return True
        return False
    
    def clear_dialog(self, dialog_id: str) -> bool:
        """Очищает историю диалога"""
        if dialog_id in self.dialogs:
            self.dialogs[dialog_id].clear_history()
            self._save_dialog(self.dialogs[dialog_id])  # Тихое сохранение
            return True
        return False
    
    def _save_dialog(self, dialog: Dialog):
        """Тихое сохранение диалога в файл"""
        try:
            dialog_file = os.path.join(self.config.save_dir, f"dialog_{dialog.id}.json")
            
            # Используем json_serialize вместо dict()
            if hasattr(dialog, 'json_serialize'):
                dialog_data = dialog.json_serialize()
            else:
                # Fallback: используем dict()
                dialog_data = dialog.dict()
                # Вручную конвертируем datetime в строки
                dialog_data["created"] = dialog.created.isoformat()
                dialog_data["updated"] = dialog.updated.isoformat()
                dialog_data["history"] = [
                    {
                        "role": msg.role.value,
                        "content": msg.content,
                        "timestamp": msg.timestamp.isoformat()
                    }
                    for msg in dialog.history
                ]
            
            with open(dialog_file, 'w', encoding='utf-8') as f:
                json.dump(dialog_data, f, ensure_ascii=False, indent=2)
                
        except Exception as e:
            # Только при реальной ошибке
            print(f"❌ Ошибка при сохранении диалога {dialog.id}: {e}")
    
    def _save_all_silent(self):
        """Тихое сохранение всех диалогов"""
        for dialog_id, dialog in self.dialogs.items():
            self._save_dialog(dialog)
    
    def load_dialogs(self):
        """Загружает сохраненные диалоги с минимальным логированием"""
        try:
            if not os.path.exists(self.config.save_dir):
                os.makedirs(self.config.save_dir, exist_ok=True)
                return
            
            dialog_files = []
            for f in os.listdir(self.config.save_dir):
                if f.startswith("dialog_") and f.endswith(".json"):
                    file_path = os.path.join(self.config.save_dir, f)
                    
                    # Проверяем, не пустой ли файл
                    if os.path.getsize(file_path) == 0:
                        os.remove(file_path)
                        continue
                    
                    dialog_files.append(file_path)
            
            if dialog_files:
                print(f"📂 Загружено {len(dialog_files)} диалогов")
            
            for file_path in dialog_files:
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        file_content = f.read().strip()
                        
                        if not file_content:
                            os.remove(file_path)
                            continue
                        
                        # Загружаем JSON
                        dialog_data = json.loads(file_content)
                
                    # Конвертируем строки datetime обратно в datetime объекты
                    dialog_data["created"] = datetime.fromisoformat(dialog_data["created"])
                    dialog_data["updated"] = datetime.fromisoformat(dialog_data["updated"])
                    
                    # Конвертируем историю сообщений
                    messages = []
                    for msg_data in dialog_data.get("history", []):
                        # Конвертируем строку timestamp в datetime
                        msg_data["timestamp"] = datetime.fromisoformat(msg_data["timestamp"])
                        # Конвертируем строку role в enum
                        msg_data["role"] = MessageRole(msg_data["role"])
                        messages.append(Message(**msg_data))
                    dialog_data["history"] = messages
                    
                    # Создаем объект Dialog
                    dialog = Dialog(**dialog_data)
                    dialog_id = dialog.id
                    self.dialogs[dialog_id] = dialog
                    
                    # Обновляем next_dialog_id
                    dialog_num = int(dialog_id)
                    if dialog_num >= self.next_dialog_id:
                        self.next_dialog_id = dialog_num + 1
                    
                except json.JSONDecodeError:
                    # Тихо удаляем поврежденный файл
                    os.remove(file_path)
                except Exception:
                    # Тихо игнорируем другие ошибки
                    pass
            
            # Устанавливаем текущий диалог как последний обновленный
            if self.dialogs:
                dialogs_list = self.get_dialog_list()
                self.current_dialog_id = dialogs_list[0]["id"]
                
        except Exception:
            # Тихо игнорируем общие ошибки
            pass

# Глобальный экземпляр
dialog_service = DialogService()
================================================================================
### services/model_service.py
================================================================================

# /services/model_service.py (уменьшим логирование)
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer
from threading import Lock
from typing import Tuple, Any

class ModelService:
    """Сервис для работы с ML моделью"""
    
    def __init__(self):
        self.config = None
        self.model = None
        self.tokenizer = None
        self.generate_lock = Lock()
        self._initialized = False
    
    def _load_config(self):
        """Ленивая загрузка конфига"""
        if self.config is None:
            from container import container
            self.config = container.get_config()
    
    def initialize(self) -> Tuple[Any, Any, Lock]:
        """Инициализирует модель и токенизатор (минимальное логирование)"""
        if self._initialized:
            return self.model, self.tokenizer, self.generate_lock
        
        self._load_config()
        model_config = self.config.model
        
        # Минимальное сообщение
        print("📦 Загрузка модели...", end="", flush=True)
        
        # Определяем dtype для тензоров
        dtype_map = {
            "float16": torch.float16,
            "bfloat16": torch.bfloat16,
            "auto": None
        }
        dtype = dtype_map.get(model_config.dtype.value, torch.bfloat16)
        
        # Загружаем токенизатор (без сообщений)
        self.tokenizer = AutoTokenizer.from_pretrained(model_config.name)
        
        # Загружаем модель (без дополнительных сообщений)
        self.model = AutoModelForCausalLM.from_pretrained(
            model_config.name,
            device_map="auto",
            dtype=dtype,
            attn_implementation=model_config.attn_implementation,
            low_cpu_mem_usage=model_config.low_cpu_mem_usage
        )
        
        # Включаем режим оценки
        self.model.eval()
        
        # Оптимизация потоков для Apple Silicon
        torch.set_num_threads(torch.get_num_threads())
        torch.set_num_interop_threads(1)
        
        self._initialized = True
        print(" ✅ Модель инициализирована")  # Завершаем сообщение галочкой
        
        return self.model, self.tokenizer, self.generate_lock
    
    def get_generation_params(self, **overrides):
        """Получает параметры генерации с возможностью переопределения"""
        if not self._initialized:
            self.initialize()
        
        self._load_config()
        gen_config = self.config.generation
        
        params = {
            "max_new_tokens": overrides.get("max_tokens", gen_config.default_max_tokens),
            "temperature": overrides.get("temperature", gen_config.default_temperature),
            "top_p": gen_config.default_top_p,
            "repetition_penalty": gen_config.default_repetition_penalty,
            "do_sample": True,
        }
        
        # Добавляем pad_token_id, если токенизатор инициализирован
        if self.tokenizer:
            params["pad_token_id"] = self.tokenizer.pad_token_id or self.tokenizer.eos_token_id
        
        return params
    
    def is_initialized(self) -> bool:
        """Проверяет, инициализирована ли модель"""
        return self._initialized
    
    def cleanup(self):
        """Очищает ресурсы модели"""
        if self.model:
            del self.model
            self.model = None
        
        if self.tokenizer:
            del self.tokenizer
            self.tokenizer = None
        
        self._initialized = False
        print("🧹 Ресурсы модели очищены")
================================================================================
### ui/components/accordions.py
================================================================================

# /ui/components/accordions.py
import gradio as gr
from ui.components.inputs import inputs

class AccordionComponents:
    """Фабрика аккордеонов"""
    
    def create_params_accordion(self) -> dict:
        """Создает аккордеон с параметрами модели"""
        with gr.Accordion("⚙️ Параметры", open=False, elem_classes="params-accordion"):
            sliders = inputs.create_params_sliders()
        
        return sliders

# Глобальный экземпляр
accordions = AccordionComponents()
================================================================================
### ui/components/button.py
================================================================================

# /ui/components/buttons.py
import gradio as gr
from container import container

class ButtonComponents:
    """Фабрика кнопок с использованием конфигов"""
    
    def __init__(self):
        self.config = container.get_config().ui
    
    def create_primary_button(self, text: str, **kwargs) -> gr.Button:
        """Создает основную кнопку"""
        return gr.Button(
            text,
            variant="primary",
            elem_classes="primary-btn",
            **kwargs
        )
    
    def create_secondary_button(self, text: str, **kwargs) -> gr.Button:
        """Создает второстепенную кнопку"""
        return gr.Button(
            text,
            variant="secondary",
            elem_classes="secondary-btn",
            **kwargs
        )
    
    def create_danger_button(self, text: str, **kwargs) -> gr.Button:
        """Создает кнопку для опасных действий"""
        return gr.Button(
            text,
            variant="stop",
            elem_classes="danger-btn",
            **kwargs
        )
    
    def create_chat_button(self) -> gr.Button:
        """Создает кнопку отправки сообщения"""
        return gr.Button(
            "Отправить",
            variant="primary",
            elem_classes="send-btn",
            scale=1
        )
    
    def create_new_chat_button(self) -> gr.Button:
        """Создает кнопку нового чата"""
        return gr.Button(
            "➕ Новый чат",
            variant="primary",
            size="lg",
            elem_classes="new-chat-btn"
        )
    
    def create_switch_chat_button(self) -> gr.Button:
        """Создает кнопку переключения чата"""
        return gr.Button(
            "🔄 Переключиться",
            variant="secondary",
            elem_classes="switch-chat-btn"
        )
    
    def create_delete_chat_button(self) -> gr.Button:
        """Создает кнопку удаления чата"""
        return gr.Button(
            "🗑️ Удалить",
            variant="stop",
            min_width=140,
            elem_classes="delete-chat-btn"
        )

# Глобальный экземпляр
buttons = ButtonComponents()
================================================================================
### ui/components/chat_bubble.py
================================================================================

# /ui/components/chat_bubble.py
import gradio as gr
from container import container

class ChatBubbleComponents:
    """Фабрика компонентов чата"""
    
    def __init__(self):
        self.config = container.get_config().ui
    
    def create_chatbot(self, **kwargs) -> gr.Chatbot:
        """Создает компонент чатбота"""
        return gr.Chatbot(
            label="",
            show_label=False,
            height=None,
            avatar_images=(None, "https://avatars.githubusercontent.com/u/1024"),
            elem_classes="chatbot",
            **kwargs
        )
    
    def create_chat_container(self, **kwargs) -> gr.Column:
        """Создает контейнер для окна чата"""
        return gr.Column(
            elem_classes="chat-window-container",
            **kwargs
        )
    
    def create_input_container(self, **kwargs) -> gr.Column:
        """Создает контейнер для поля ввода"""
        return gr.Column(
            elem_classes="input-plate",
            **kwargs
        )
    
    def create_input_row(self, **kwargs) -> gr.Row:
        """Создает строку для поля ввода и кнопки"""
        return gr.Row(
            elem_classes="input-row",
            **kwargs
        )
    
    def create_chat_input_wrapper(self, **kwargs) -> gr.Column:
        """Создает обертку для поля ввода"""
        return gr.Column(
            elem_classes="chat-input-wrapper",
            **kwargs
        )
    
    def create_button_wrapper(self, **kwargs) -> gr.Column:
        """Создает обертку для кнопки"""
        return gr.Column(
            elem_classes="send-btn-wrapper",
            **kwargs
        )

# Глобальный экземпляр
chat_bubbles = ChatBubbleComponents()
================================================================================
### ui/components/inputs.py
================================================================================

# /ui/components/inputs.py
import gradio as gr
from container import container

class InputComponents:
    """Фабрика полей ввода с использованием конфигов"""
    
    def __init__(self):
        self.config = container.get_config().ui
    
    def create_chat_input(self, **kwargs) -> gr.Textbox:
        """Создает поле ввода для чата"""
        return gr.Textbox(
            placeholder="Введите сообщение...",
            lines=4,
            show_label=False,
            elem_classes="chat-input",
            max_lines=4,
            scale=9,
            **kwargs
        )
    
    def create_dropdown(self, choices: list = None, **kwargs) -> gr.Dropdown:
        """Создает выпадающий список"""
        return gr.Dropdown(
            choices=choices or [],
            interactive=True,
            scale=1,
            show_label=False,
            **kwargs
        )
    
    def create_slider(self, label: str, min_value: float, max_value: float, 
                     value: float, step: float = None, **kwargs) -> gr.Slider:
        """Создает слайдер"""
        return gr.Slider(
            minimum=min_value,
            maximum=max_value,
            value=value,
            step=step,
            label=label,
            **kwargs
        )
    
    def create_params_sliders(self) -> dict:
        """Создает слайдеры параметров модели"""
        gen_config = container.get_config().generation
        
        max_tokens = self.create_slider(
            label="Максимальное количество токенов",
            min_value=gen_config.min_max_tokens,
            max_value=gen_config.max_max_tokens,
            value=gen_config.default_max_tokens,
            step=64
        )
        
        temperature = self.create_slider(
            label="Температура",
            min_value=gen_config.min_temperature,
            max_value=gen_config.max_temperature,
            value=gen_config.default_temperature,
            step=0.1
        )
        
        return {
            "max_tokens": max_tokens,
            "temperature": temperature
        }

# Глобальный экземпляр
inputs = InputComponents()
================================================================================
### ui/layouts/__init__.py
================================================================================

# /ui/layouts/__init__.py
# Пустой файл для обозначения пакета
================================================================================
### ui/layouts/chat_layout.py
================================================================================

# /ui/layouts/chat_layout.py
import gradio as gr

def create_chat_layout():
    """Создает layout чата и возвращает компоненты"""
    chatbot = gr.Chatbot(
        label="",
        show_label=False,
        height=None,
        avatar_images=(None, "https://avatars.githubusercontent.com/u/1024"),
        elem_classes="chatbot"
    )
    
    with gr.Column(elem_classes="chat-main-container"):
        # Окно чата
        with gr.Column(elem_classes="chat-window-container"):
            pass  # Chatbot уже создан выше
        
        # Общая плашка для ввода и кнопки
        with gr.Column(elem_classes="input-plate"):
            with gr.Row(elem_classes="input-row"):
                # Контейнер для поля ввода
                with gr.Column(elem_classes="chat-input-wrapper"):
                    user_input = gr.Textbox(
                        placeholder="Введите сообщение...",
                        lines=4,
                        show_label=False,
                        elem_classes="chat-input",
                        max_lines=4,
                        scale=9
                    )
                # Контейнер для кнопки
                with gr.Column(elem_classes="send-btn-wrapper"):
                    submit_btn = gr.Button(
                        "Отправить", 
                        variant="primary", 
                        elem_classes="send-btn",
                        scale=1
                    )
    
    return chatbot, user_input, submit_btn
================================================================================
### ui/layouts/main_layout.py
================================================================================

# /ui/layouts/main_layout.py
import gradio as gr

def create_main_layout():
    """Создает главный layout приложения"""
    with gr.Row(elem_classes="main-row"):
        # Сайдбар
        from ui.layouts.sidebar_layout import create_sidebar_layout
        sidebar_components = create_sidebar_layout()
        
        # Основное содержимое
        with gr.Column(elem_classes="main-content"):
            with gr.Column(elem_classes="chat-main-container"):
                # Окно чата
                with gr.Column(elem_classes="chat-window-container", elem_id="chat_window"):
                    chatbot = gr.Chatbot(
                        label="",
                        show_label=False,
                        height=None,
                        avatar_images=(None, "https://avatars.githubusercontent.com/u/1024"),
                        elem_classes="chatbot",
                        container=True  # ← Ключевой параметр
                    )
                
                # Область ввода
                with gr.Column(elem_classes="input-plate"):
                    with gr.Row(elem_classes="input-row"):
                        with gr.Column(elem_classes="chat-input-wrapper"):
                            user_input = gr.Textbox(
                                placeholder="Введите сообщение...",
                                lines=4,
                                show_label=False,
                                elem_classes="chat-input",
                                max_lines=4,
                                scale=9
                            )
                        with gr.Column(elem_classes="send-btn-wrapper"):
                            submit_btn = gr.Button(
                                "Отправить", 
                                variant="primary", 
                                elem_classes="send-btn",
                                scale=1
                            )
    
    return sidebar_components, chatbot, user_input, submit_btn
================================================================================
### ui/layouts/sidebar_layout.py
================================================================================

# /ui/layouts/sidebar_layout.py
import gradio as gr

def create_sidebar_layout():
    """Создает layout боковой панели"""
    with gr.Column(scale=1, min_width=300, elem_id="sidebar_container"):
        # Выбор чата
        dialog_dropdown = gr.Dropdown(
            choices=[],
            interactive=True,
            scale=1,
            show_label=False
        )
        
        with gr.Row():
            switch_dialog_btn = gr.Button("🔄 Переключиться", variant="secondary")
        
        # Разделитель
        gr.HTML("<hr class='sidebar-divider'>")
        
        with gr.Row():
            delete_dialog_btn = gr.Button("🗑️ Удалить", variant="stop", min_width=140)
        
        # Разделитель
        gr.HTML("<hr class='sidebar-divider'>")
        
        # Кнопка создания нового чата
        create_dialog_btn = gr.Button("➕ Новый чат", variant="primary", size="lg")
        
        # Разделитель
        gr.HTML("<hr class='sidebar-divider'>")
        
        # Параметры модели
        with gr.Accordion("⚙️ Параметры", open=False, elem_classes="params-accordion"):
            max_tokens = gr.Slider(
                minimum=64, maximum=2048, value=512, step=64,
                label="Максимальное количество токенов"
            )
            temperature = gr.Slider(
                minimum=0.1, maximum=1.5, value=0.7, step=0.1,
                label="Температура"
            )
        
        # Статус
        status_text = gr.Markdown("✅ Готов к работе")
    
    return {
        "create_dialog_btn": create_dialog_btn,
        "dialog_dropdown": dialog_dropdown,
        "switch_dialog_btn": switch_dialog_btn,
        "delete_dialog_btn": delete_dialog_btn,
        "status_text": status_text,
        "max_tokens": max_tokens,
        "temperature": temperature
    }
================================================================================
### ui/main.py
================================================================================

# /ui/main.py
import gradio as gr
import os
from ui.layouts.main_layout import create_main_layout
from logic.ui_handlers import ui_handlers

def load_css():
    """Загружает все CSS файлы"""
    css_files = [
        'css/base.css',
        'css/sidebar.css', 
        'css/chat_window.css',
        'css/input_area.css'
    ]
    
    css_content = ""
    
    for css_file in css_files:
        try:
            if os.path.exists(css_file):
                with open(css_file, 'r', encoding='utf-8') as f:
                    css_content += f.read() + "\n"
            else:
                print(f"⚠️ CSS файл не найден: {css_file}")
        except Exception as e:
            print(f"⚠️ Ошибка загрузки CSS файла {css_file}: {e}")
    
    return css_content

def create_main_ui():
    """Создает основной UI интерфейс с привязанной логикой"""
    
    # Загружаем CSS (но не передаем в Blocks)
    css_content = load_css()
    
    # Убираем css из gr.Blocks() - только title
    with gr.Blocks(title="Qwen3-4B Chat") as demo:
        current_dialog_id = gr.State(value=None)
        
        # Создаем layout
        sidebar_components, chatbot, user_input, submit_btn = create_main_layout()
        
        # 1. Создание нового чата - 6 OUTPUTS
        sidebar_components["create_dialog_btn"].click(
            fn=ui_handlers.create_chat_handler,
            inputs=[],
            outputs=[
                chatbot,           # 0 - история чата
                user_input,        # 1 - очистить поле ввода
                current_dialog_id, # 2 - ID текущего диалога
                sidebar_components["dialog_dropdown"],  # 3 - обновить dropdown
                sidebar_components["status_text"],      # 4 - обновить статус
                chatbot            # 5 - обновить label чата
            ]
        )
        
        # 2. Переключение чата - 6 OUTPUTS
        sidebar_components["switch_dialog_btn"].click(
            fn=ui_handlers.switch_chat_handler,
            inputs=[sidebar_components["dialog_dropdown"]],
            outputs=[
                chatbot,
                user_input,
                current_dialog_id,
                sidebar_components["dialog_dropdown"],
                sidebar_components["status_text"],
                chatbot
            ]
        )
        
        # 3. Удаление чата - 6 OUTPUTS
        sidebar_components["delete_dialog_btn"].click(
            fn=ui_handlers.delete_chat_handler,
            inputs=[sidebar_components["dialog_dropdown"]],
            outputs=[
                chatbot,
                user_input,
                current_dialog_id,
                sidebar_components["dialog_dropdown"],
                sidebar_components["status_text"],
                chatbot
            ]
        )
        
        # 4. Функция отправки сообщения - ТОЛЬКО 5 OUTPUTS
        def send_message(prompt, chat_id):
            """Обертка для отправки сообщения"""
            max_t = sidebar_components["max_tokens"].value
            temp = sidebar_components["temperature"].value
            return ui_handlers.send_message_handler(prompt, chat_id, max_t, temp)
        
        # 5. Отправка по кнопке - ТОЛЬКО 5 OUTPUTS
        submit_btn.click(
            fn=send_message,
            inputs=[user_input, current_dialog_id],
            outputs=[
                chatbot,           # 0 - история чата
                user_input,        # 1 - очистить поле ввода
                current_dialog_id, # 2 - ID текущего диалога
                sidebar_components["dialog_dropdown"],  # 3 - обновить dropdown
                chatbot            # 4 - обновить label чата
            ]
        )
        
        # 6. Отправка по Enter - ТОЛЬКО 5 OUTPUTS
        user_input.submit(
            fn=send_message,
            inputs=[user_input, current_dialog_id],
            outputs=[
                chatbot,
                user_input,
                current_dialog_id,
                sidebar_components["dialog_dropdown"],
                chatbot
            ]
        )
        
        # 7. Инициализация - ТОЛЬКО 4 OUTPUTS
        demo.load(
            fn=ui_handlers.init_app_handler,
            outputs=[
                chatbot,           # 0 - история чата
                current_dialog_id, # 1 - ID текущего диалога
                sidebar_components["dialog_dropdown"],  # 2 - обновить dropdown
                chatbot            # 3 - обновить label чата
            ]
        )
    
    return demo, css_content

def get_css_content():
    """Возвращает CSS контент для launch()"""
    return load_css()